<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fpdf.line_break API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.line_break</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import NamedTuple, Any, Union, Sequence

from .errors import FPDFException

SOFT_HYPHEN = &#34;\u00ad&#34;
HYPHEN = &#34;\u002d&#34;
SPACE = &#34; &#34;
NEWLINE = &#34;\n&#34;


class Fragment:
    def __init__(self, style: str, underlined: bool, characters: str = None):
        self.style = style
        self.underline = underlined
        self.characters = [] if characters is None else characters

    def __repr__(self):
        return f&#34;Fragment(style={self.style}, underline={self.underline}, characters={self.characters})&#34;

    @classmethod
    def from_string(cls, string: str, style: str, underlined: bool):
        return cls(style, underlined, list(string))

    def trim(self, index: int):
        self.characters = self.characters[:index]

    @property
    def string(self):
        return &#34;&#34;.join(self.characters)

    def __eq__(self, other: Any):
        return (
            self.characters == other.characters
            and self.style == other.style
            and self.underline == other.underline
        )


class TextLine(NamedTuple):
    fragments: tuple
    text_width: float
    number_of_spaces_between_words: int
    justify: bool
    trailing_nl: bool


class SpaceHint(NamedTuple):
    original_fragment_index: int
    original_character_index: int
    current_line_fragment_index: int
    current_line_character_index: int
    width: float
    number_of_spaces: int


class HyphenHint(NamedTuple):
    original_fragment_index: int
    original_character_index: int
    current_line_fragment_index: int
    current_line_character_index: int
    width: float
    number_of_spaces: int
    character_to_append: str
    character_to_append_width: float
    character_to_append_style: str
    character_to_append_underline: bool


class CurrentLine:
    def __init__(self, print_sh: bool = False):
        &#34;&#34;&#34;
        Per-line text fragment management for use by MultiLineBreak.
            Args:
                print_sh (bool): If true, a soft-hyphen will be rendered
                    normally, instead of triggering a line break. Default: False
        &#34;&#34;&#34;
        self.print_sh = print_sh
        self.fragments = []
        self.width = 0
        self.number_of_spaces = 0

        # automatic break hints
        # CurrentLine class remembers 3 positions
        # 1 - position of last inserted character.
        #     class attributes (`width`, `fragments`)
        #     is used for this purpose
        # 2 - position of last inserted space
        #     SpaceHint is used fo this purpose.
        # 3 - position of last inserted soft-hyphen
        #     HyphenHint is used fo this purpose.
        # The purpose of multiple positions tracking - to have an ability
        # to break in multiple places, depending on condition.
        self.space_break_hint = None
        self.hyphen_break_hint = None

    def add_character(
        self,
        character: str,
        character_width: float,
        style: str,
        underline: bool,
        original_fragment_index: int,
        original_character_index: int,
    ):
        assert character != NEWLINE

        if not self.fragments:
            self.fragments.append(Fragment(style, underline))

        # characters are expected to be grouped into fragments by styles and
        # underline attributes. If the last existing fragment doesn&#39;t match
        # the (style, underline) of pending character -&gt;
        # create a new fragment with matching (style, underline)
        elif (
            style != self.fragments[-1].style
            or underline != self.fragments[-1].underline
        ):
            self.fragments.append(Fragment(style, underline))
        active_fragment = self.fragments[-1]

        if character == SPACE:
            self.space_break_hint = SpaceHint(
                original_fragment_index,
                original_character_index,
                len(self.fragments),
                len(active_fragment.characters),
                self.width,
                self.number_of_spaces,
            )
            self.number_of_spaces += 1
        elif character == SOFT_HYPHEN and not self.print_sh:
            self.hyphen_break_hint = HyphenHint(
                original_fragment_index,
                original_character_index,
                len(self.fragments),
                len(active_fragment.characters),
                self.width,
                self.number_of_spaces,
                HYPHEN,
                character_width,
                style,
                underline,
            )

        if character != SOFT_HYPHEN or self.print_sh:
            self.width += character_width
            active_fragment.characters.append(character)

    def _apply_automatic_hint(self, break_hint: Union[SpaceHint, HyphenHint]):
        &#34;&#34;&#34;
        This function mutates the current_line, applying one of the states
        observed in the past and stored in
        `hyphen_break_hint` or `space_break_hint` attributes.
        &#34;&#34;&#34;
        self.fragments = self.fragments[: break_hint.current_line_fragment_index]
        if self.fragments:
            self.fragments[-1].trim(break_hint.current_line_character_index)
        self.number_of_spaces = break_hint.number_of_spaces
        self.width = break_hint.width

    def manual_break(self, justify: bool = False, trailing_nl: bool = False):
        return TextLine(
            fragments=self.fragments,
            text_width=self.width,
            number_of_spaces_between_words=self.number_of_spaces,
            justify=(self.number_of_spaces &gt; 0) and justify,
            trailing_nl=trailing_nl,
        )

    def automatic_break_possible(self):
        return self.hyphen_break_hint is not None or self.space_break_hint is not None

    def automatic_break(self, justify: bool):
        assert self.automatic_break_possible()
        if self.hyphen_break_hint is not None and (
            self.space_break_hint is None
            or self.hyphen_break_hint.width &gt; self.space_break_hint.width
        ):
            self._apply_automatic_hint(self.hyphen_break_hint)
            self.add_character(
                self.hyphen_break_hint.character_to_append,
                self.hyphen_break_hint.character_to_append_width,
                self.hyphen_break_hint.character_to_append_style,
                self.hyphen_break_hint.character_to_append_underline,
                self.hyphen_break_hint.original_fragment_index,
                self.hyphen_break_hint.original_character_index,
            )
            return (
                self.hyphen_break_hint.original_fragment_index,
                self.hyphen_break_hint.original_character_index,
                self.manual_break(justify),
            )
        self._apply_automatic_hint(self.space_break_hint)
        return (
            self.space_break_hint.original_fragment_index,
            self.space_break_hint.original_character_index,
            self.manual_break(justify),
        )


class MultiLineBreak:
    def __init__(
        self,
        styled_text_fragments: Sequence,
        size_by_style: Sequence,
        justify: bool = False,
        print_sh: bool = False,
    ):
        self.styled_text_fragments = styled_text_fragments
        self.size_by_style = size_by_style
        self.justify = justify
        self.print_sh = print_sh
        self.fragment_index = 0
        self.character_index = 0
        self.char_index_for_last_forced_manual_break = None

    def _get_character_width(self, character: str, style: str = &#34;&#34;):
        if character == SOFT_HYPHEN and not self.print_sh:
            # HYPHEN is inserted instead of SOFT_HYPHEN
            character = HYPHEN
        return self.size_by_style(character, style)

    # pylint: disable=too-many-return-statements
    def get_line_of_given_width(self, maximum_width: float, wordsplit: bool = True):
        char_index_for_last_forced_manual_break = (
            self.char_index_for_last_forced_manual_break
        )
        self.char_index_for_last_forced_manual_break = None

        if self.fragment_index == len(self.styled_text_fragments):
            return None

        last_fragment_index = self.fragment_index
        last_character_index = self.character_index
        line_full = False

        current_line = CurrentLine(print_sh=self.print_sh)
        while self.fragment_index &lt; len(self.styled_text_fragments):

            current_fragment = self.styled_text_fragments[self.fragment_index]

            if self.character_index &gt;= len(current_fragment.characters):
                self.character_index = 0
                self.fragment_index += 1
                continue

            character = current_fragment.characters[self.character_index]
            character_width = self._get_character_width(
                character, current_fragment.style
            )

            if character == NEWLINE:
                self.character_index += 1
                return current_line.manual_break(trailing_nl=True)

            if current_line.width + character_width &gt; maximum_width:
                if character == SPACE:
                    self.character_index += 1
                    return current_line.manual_break(self.justify)
                if current_line.automatic_break_possible():
                    (
                        self.fragment_index,
                        self.character_index,
                        line,
                    ) = current_line.automatic_break(self.justify)
                    self.character_index += 1
                    return line
                if not wordsplit:
                    line_full = True
                    break
                if char_index_for_last_forced_manual_break == self.character_index:
                    raise FPDFException(
                        &#34;Not enough horizontal space to render a single character&#34;
                    )
                self.char_index_for_last_forced_manual_break = self.character_index
                return current_line.manual_break()

            current_line.add_character(
                character,
                character_width,
                current_fragment.style,
                current_fragment.underline,
                self.fragment_index,
                self.character_index,
            )

            self.character_index += 1

        if line_full and not wordsplit:
            # roll back and return empty line to trigger continuation
            # on the next line.
            self.fragment_index = last_fragment_index
            self.character_index = last_character_index
            return CurrentLine().manual_break(self.justify)
        if current_line.width:
            return current_line.manual_break()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.line_break.CurrentLine"><code class="flex name class">
<span>class <span class="ident">CurrentLine</span></span>
<span>(</span><span>print_sh: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Per-line text fragment management for use by MultiLineBreak.
Args:
print_sh (bool): If true, a soft-hyphen will be rendered
normally, instead of triggering a line break. Default: False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CurrentLine:
    def __init__(self, print_sh: bool = False):
        &#34;&#34;&#34;
        Per-line text fragment management for use by MultiLineBreak.
            Args:
                print_sh (bool): If true, a soft-hyphen will be rendered
                    normally, instead of triggering a line break. Default: False
        &#34;&#34;&#34;
        self.print_sh = print_sh
        self.fragments = []
        self.width = 0
        self.number_of_spaces = 0

        # automatic break hints
        # CurrentLine class remembers 3 positions
        # 1 - position of last inserted character.
        #     class attributes (`width`, `fragments`)
        #     is used for this purpose
        # 2 - position of last inserted space
        #     SpaceHint is used fo this purpose.
        # 3 - position of last inserted soft-hyphen
        #     HyphenHint is used fo this purpose.
        # The purpose of multiple positions tracking - to have an ability
        # to break in multiple places, depending on condition.
        self.space_break_hint = None
        self.hyphen_break_hint = None

    def add_character(
        self,
        character: str,
        character_width: float,
        style: str,
        underline: bool,
        original_fragment_index: int,
        original_character_index: int,
    ):
        assert character != NEWLINE

        if not self.fragments:
            self.fragments.append(Fragment(style, underline))

        # characters are expected to be grouped into fragments by styles and
        # underline attributes. If the last existing fragment doesn&#39;t match
        # the (style, underline) of pending character -&gt;
        # create a new fragment with matching (style, underline)
        elif (
            style != self.fragments[-1].style
            or underline != self.fragments[-1].underline
        ):
            self.fragments.append(Fragment(style, underline))
        active_fragment = self.fragments[-1]

        if character == SPACE:
            self.space_break_hint = SpaceHint(
                original_fragment_index,
                original_character_index,
                len(self.fragments),
                len(active_fragment.characters),
                self.width,
                self.number_of_spaces,
            )
            self.number_of_spaces += 1
        elif character == SOFT_HYPHEN and not self.print_sh:
            self.hyphen_break_hint = HyphenHint(
                original_fragment_index,
                original_character_index,
                len(self.fragments),
                len(active_fragment.characters),
                self.width,
                self.number_of_spaces,
                HYPHEN,
                character_width,
                style,
                underline,
            )

        if character != SOFT_HYPHEN or self.print_sh:
            self.width += character_width
            active_fragment.characters.append(character)

    def _apply_automatic_hint(self, break_hint: Union[SpaceHint, HyphenHint]):
        &#34;&#34;&#34;
        This function mutates the current_line, applying one of the states
        observed in the past and stored in
        `hyphen_break_hint` or `space_break_hint` attributes.
        &#34;&#34;&#34;
        self.fragments = self.fragments[: break_hint.current_line_fragment_index]
        if self.fragments:
            self.fragments[-1].trim(break_hint.current_line_character_index)
        self.number_of_spaces = break_hint.number_of_spaces
        self.width = break_hint.width

    def manual_break(self, justify: bool = False, trailing_nl: bool = False):
        return TextLine(
            fragments=self.fragments,
            text_width=self.width,
            number_of_spaces_between_words=self.number_of_spaces,
            justify=(self.number_of_spaces &gt; 0) and justify,
            trailing_nl=trailing_nl,
        )

    def automatic_break_possible(self):
        return self.hyphen_break_hint is not None or self.space_break_hint is not None

    def automatic_break(self, justify: bool):
        assert self.automatic_break_possible()
        if self.hyphen_break_hint is not None and (
            self.space_break_hint is None
            or self.hyphen_break_hint.width &gt; self.space_break_hint.width
        ):
            self._apply_automatic_hint(self.hyphen_break_hint)
            self.add_character(
                self.hyphen_break_hint.character_to_append,
                self.hyphen_break_hint.character_to_append_width,
                self.hyphen_break_hint.character_to_append_style,
                self.hyphen_break_hint.character_to_append_underline,
                self.hyphen_break_hint.original_fragment_index,
                self.hyphen_break_hint.original_character_index,
            )
            return (
                self.hyphen_break_hint.original_fragment_index,
                self.hyphen_break_hint.original_character_index,
                self.manual_break(justify),
            )
        self._apply_automatic_hint(self.space_break_hint)
        return (
            self.space_break_hint.original_fragment_index,
            self.space_break_hint.original_character_index,
            self.manual_break(justify),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.line_break.CurrentLine.add_character"><code class="name flex">
<span>def <span class="ident">add_character</span></span>(<span>self, character: str, character_width: float, style: str, underline: bool, original_fragment_index: int, original_character_index: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_character(
    self,
    character: str,
    character_width: float,
    style: str,
    underline: bool,
    original_fragment_index: int,
    original_character_index: int,
):
    assert character != NEWLINE

    if not self.fragments:
        self.fragments.append(Fragment(style, underline))

    # characters are expected to be grouped into fragments by styles and
    # underline attributes. If the last existing fragment doesn&#39;t match
    # the (style, underline) of pending character -&gt;
    # create a new fragment with matching (style, underline)
    elif (
        style != self.fragments[-1].style
        or underline != self.fragments[-1].underline
    ):
        self.fragments.append(Fragment(style, underline))
    active_fragment = self.fragments[-1]

    if character == SPACE:
        self.space_break_hint = SpaceHint(
            original_fragment_index,
            original_character_index,
            len(self.fragments),
            len(active_fragment.characters),
            self.width,
            self.number_of_spaces,
        )
        self.number_of_spaces += 1
    elif character == SOFT_HYPHEN and not self.print_sh:
        self.hyphen_break_hint = HyphenHint(
            original_fragment_index,
            original_character_index,
            len(self.fragments),
            len(active_fragment.characters),
            self.width,
            self.number_of_spaces,
            HYPHEN,
            character_width,
            style,
            underline,
        )

    if character != SOFT_HYPHEN or self.print_sh:
        self.width += character_width
        active_fragment.characters.append(character)</code></pre>
</details>
</dd>
<dt id="fpdf.line_break.CurrentLine.automatic_break"><code class="name flex">
<span>def <span class="ident">automatic_break</span></span>(<span>self, justify: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def automatic_break(self, justify: bool):
    assert self.automatic_break_possible()
    if self.hyphen_break_hint is not None and (
        self.space_break_hint is None
        or self.hyphen_break_hint.width &gt; self.space_break_hint.width
    ):
        self._apply_automatic_hint(self.hyphen_break_hint)
        self.add_character(
            self.hyphen_break_hint.character_to_append,
            self.hyphen_break_hint.character_to_append_width,
            self.hyphen_break_hint.character_to_append_style,
            self.hyphen_break_hint.character_to_append_underline,
            self.hyphen_break_hint.original_fragment_index,
            self.hyphen_break_hint.original_character_index,
        )
        return (
            self.hyphen_break_hint.original_fragment_index,
            self.hyphen_break_hint.original_character_index,
            self.manual_break(justify),
        )
    self._apply_automatic_hint(self.space_break_hint)
    return (
        self.space_break_hint.original_fragment_index,
        self.space_break_hint.original_character_index,
        self.manual_break(justify),
    )</code></pre>
</details>
</dd>
<dt id="fpdf.line_break.CurrentLine.automatic_break_possible"><code class="name flex">
<span>def <span class="ident">automatic_break_possible</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def automatic_break_possible(self):
    return self.hyphen_break_hint is not None or self.space_break_hint is not None</code></pre>
</details>
</dd>
<dt id="fpdf.line_break.CurrentLine.manual_break"><code class="name flex">
<span>def <span class="ident">manual_break</span></span>(<span>self, justify: bool = False, trailing_nl: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manual_break(self, justify: bool = False, trailing_nl: bool = False):
    return TextLine(
        fragments=self.fragments,
        text_width=self.width,
        number_of_spaces_between_words=self.number_of_spaces,
        justify=(self.number_of_spaces &gt; 0) and justify,
        trailing_nl=trailing_nl,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.line_break.Fragment"><code class="flex name class">
<span>class <span class="ident">Fragment</span></span>
<span>(</span><span>style: str, underlined: bool, characters: str = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fragment:
    def __init__(self, style: str, underlined: bool, characters: str = None):
        self.style = style
        self.underline = underlined
        self.characters = [] if characters is None else characters

    def __repr__(self):
        return f&#34;Fragment(style={self.style}, underline={self.underline}, characters={self.characters})&#34;

    @classmethod
    def from_string(cls, string: str, style: str, underlined: bool):
        return cls(style, underlined, list(string))

    def trim(self, index: int):
        self.characters = self.characters[:index]

    @property
    def string(self):
        return &#34;&#34;.join(self.characters)

    def __eq__(self, other: Any):
        return (
            self.characters == other.characters
            and self.style == other.style
            and self.underline == other.underline
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.line_break.Fragment.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>string: str, style: str, underlined: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, string: str, style: str, underlined: bool):
    return cls(style, underlined, list(string))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.line_break.Fragment.string"><code class="name">var <span class="ident">string</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def string(self):
    return &#34;&#34;.join(self.characters)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.line_break.Fragment.trim"><code class="name flex">
<span>def <span class="ident">trim</span></span>(<span>self, index: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim(self, index: int):
    self.characters = self.characters[:index]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.line_break.HyphenHint"><code class="flex name class">
<span>class <span class="ident">HyphenHint</span></span>
<span>(</span><span>original_fragment_index: int, original_character_index: int, current_line_fragment_index: int, current_line_character_index: int, width: float, number_of_spaces: int, character_to_append: str, character_to_append_width: float, character_to_append_style: str, character_to_append_underline: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>HyphenHint(original_fragment_index, original_character_index, current_line_fragment_index, current_line_character_index, width, number_of_spaces, character_to_append, character_to_append_width, character_to_append_style, character_to_append_underline)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HyphenHint(NamedTuple):
    original_fragment_index: int
    original_character_index: int
    current_line_fragment_index: int
    current_line_character_index: int
    width: float
    number_of_spaces: int
    character_to_append: str
    character_to_append_width: float
    character_to_append_style: str
    character_to_append_underline: bool</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.line_break.HyphenHint.character_to_append"><code class="name">var <span class="ident">character_to_append</span> : str</code></dt>
<dd>
<div class="desc"><p>Alias for field number 6</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.character_to_append_style"><code class="name">var <span class="ident">character_to_append_style</span> : str</code></dt>
<dd>
<div class="desc"><p>Alias for field number 8</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.character_to_append_underline"><code class="name">var <span class="ident">character_to_append_underline</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 9</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.character_to_append_width"><code class="name">var <span class="ident">character_to_append_width</span> : float</code></dt>
<dd>
<div class="desc"><p>Alias for field number 7</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.current_line_character_index"><code class="name">var <span class="ident">current_line_character_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.current_line_fragment_index"><code class="name">var <span class="ident">current_line_fragment_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.number_of_spaces"><code class="name">var <span class="ident">number_of_spaces</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.original_character_index"><code class="name">var <span class="ident">original_character_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.original_fragment_index"><code class="name">var <span class="ident">original_fragment_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="fpdf.line_break.HyphenHint.width"><code class="name">var <span class="ident">width</span> : float</code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.line_break.MultiLineBreak"><code class="flex name class">
<span>class <span class="ident">MultiLineBreak</span></span>
<span>(</span><span>styled_text_fragments: Sequence, size_by_style: Sequence, justify: bool = False, print_sh: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiLineBreak:
    def __init__(
        self,
        styled_text_fragments: Sequence,
        size_by_style: Sequence,
        justify: bool = False,
        print_sh: bool = False,
    ):
        self.styled_text_fragments = styled_text_fragments
        self.size_by_style = size_by_style
        self.justify = justify
        self.print_sh = print_sh
        self.fragment_index = 0
        self.character_index = 0
        self.char_index_for_last_forced_manual_break = None

    def _get_character_width(self, character: str, style: str = &#34;&#34;):
        if character == SOFT_HYPHEN and not self.print_sh:
            # HYPHEN is inserted instead of SOFT_HYPHEN
            character = HYPHEN
        return self.size_by_style(character, style)

    # pylint: disable=too-many-return-statements
    def get_line_of_given_width(self, maximum_width: float, wordsplit: bool = True):
        char_index_for_last_forced_manual_break = (
            self.char_index_for_last_forced_manual_break
        )
        self.char_index_for_last_forced_manual_break = None

        if self.fragment_index == len(self.styled_text_fragments):
            return None

        last_fragment_index = self.fragment_index
        last_character_index = self.character_index
        line_full = False

        current_line = CurrentLine(print_sh=self.print_sh)
        while self.fragment_index &lt; len(self.styled_text_fragments):

            current_fragment = self.styled_text_fragments[self.fragment_index]

            if self.character_index &gt;= len(current_fragment.characters):
                self.character_index = 0
                self.fragment_index += 1
                continue

            character = current_fragment.characters[self.character_index]
            character_width = self._get_character_width(
                character, current_fragment.style
            )

            if character == NEWLINE:
                self.character_index += 1
                return current_line.manual_break(trailing_nl=True)

            if current_line.width + character_width &gt; maximum_width:
                if character == SPACE:
                    self.character_index += 1
                    return current_line.manual_break(self.justify)
                if current_line.automatic_break_possible():
                    (
                        self.fragment_index,
                        self.character_index,
                        line,
                    ) = current_line.automatic_break(self.justify)
                    self.character_index += 1
                    return line
                if not wordsplit:
                    line_full = True
                    break
                if char_index_for_last_forced_manual_break == self.character_index:
                    raise FPDFException(
                        &#34;Not enough horizontal space to render a single character&#34;
                    )
                self.char_index_for_last_forced_manual_break = self.character_index
                return current_line.manual_break()

            current_line.add_character(
                character,
                character_width,
                current_fragment.style,
                current_fragment.underline,
                self.fragment_index,
                self.character_index,
            )

            self.character_index += 1

        if line_full and not wordsplit:
            # roll back and return empty line to trigger continuation
            # on the next line.
            self.fragment_index = last_fragment_index
            self.character_index = last_character_index
            return CurrentLine().manual_break(self.justify)
        if current_line.width:
            return current_line.manual_break()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.line_break.MultiLineBreak.get_line_of_given_width"><code class="name flex">
<span>def <span class="ident">get_line_of_given_width</span></span>(<span>self, maximum_width: float, wordsplit: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_line_of_given_width(self, maximum_width: float, wordsplit: bool = True):
    char_index_for_last_forced_manual_break = (
        self.char_index_for_last_forced_manual_break
    )
    self.char_index_for_last_forced_manual_break = None

    if self.fragment_index == len(self.styled_text_fragments):
        return None

    last_fragment_index = self.fragment_index
    last_character_index = self.character_index
    line_full = False

    current_line = CurrentLine(print_sh=self.print_sh)
    while self.fragment_index &lt; len(self.styled_text_fragments):

        current_fragment = self.styled_text_fragments[self.fragment_index]

        if self.character_index &gt;= len(current_fragment.characters):
            self.character_index = 0
            self.fragment_index += 1
            continue

        character = current_fragment.characters[self.character_index]
        character_width = self._get_character_width(
            character, current_fragment.style
        )

        if character == NEWLINE:
            self.character_index += 1
            return current_line.manual_break(trailing_nl=True)

        if current_line.width + character_width &gt; maximum_width:
            if character == SPACE:
                self.character_index += 1
                return current_line.manual_break(self.justify)
            if current_line.automatic_break_possible():
                (
                    self.fragment_index,
                    self.character_index,
                    line,
                ) = current_line.automatic_break(self.justify)
                self.character_index += 1
                return line
            if not wordsplit:
                line_full = True
                break
            if char_index_for_last_forced_manual_break == self.character_index:
                raise FPDFException(
                    &#34;Not enough horizontal space to render a single character&#34;
                )
            self.char_index_for_last_forced_manual_break = self.character_index
            return current_line.manual_break()

        current_line.add_character(
            character,
            character_width,
            current_fragment.style,
            current_fragment.underline,
            self.fragment_index,
            self.character_index,
        )

        self.character_index += 1

    if line_full and not wordsplit:
        # roll back and return empty line to trigger continuation
        # on the next line.
        self.fragment_index = last_fragment_index
        self.character_index = last_character_index
        return CurrentLine().manual_break(self.justify)
    if current_line.width:
        return current_line.manual_break()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.line_break.SpaceHint"><code class="flex name class">
<span>class <span class="ident">SpaceHint</span></span>
<span>(</span><span>original_fragment_index: int, original_character_index: int, current_line_fragment_index: int, current_line_character_index: int, width: float, number_of_spaces: int)</span>
</code></dt>
<dd>
<div class="desc"><p>SpaceHint(original_fragment_index, original_character_index, current_line_fragment_index, current_line_character_index, width, number_of_spaces)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpaceHint(NamedTuple):
    original_fragment_index: int
    original_character_index: int
    current_line_fragment_index: int
    current_line_character_index: int
    width: float
    number_of_spaces: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.line_break.SpaceHint.current_line_character_index"><code class="name">var <span class="ident">current_line_character_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="fpdf.line_break.SpaceHint.current_line_fragment_index"><code class="name">var <span class="ident">current_line_fragment_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="fpdf.line_break.SpaceHint.number_of_spaces"><code class="name">var <span class="ident">number_of_spaces</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="fpdf.line_break.SpaceHint.original_character_index"><code class="name">var <span class="ident">original_character_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="fpdf.line_break.SpaceHint.original_fragment_index"><code class="name">var <span class="ident">original_fragment_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="fpdf.line_break.SpaceHint.width"><code class="name">var <span class="ident">width</span> : float</code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.line_break.TextLine"><code class="flex name class">
<span>class <span class="ident">TextLine</span></span>
<span>(</span><span>fragments: tuple, text_width: float, number_of_spaces_between_words: int, justify: bool, trailing_nl: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>TextLine(fragments, text_width, number_of_spaces_between_words, justify, trailing_nl)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextLine(NamedTuple):
    fragments: tuple
    text_width: float
    number_of_spaces_between_words: int
    justify: bool
    trailing_nl: bool</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.line_break.TextLine.fragments"><code class="name">var <span class="ident">fragments</span> : tuple</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="fpdf.line_break.TextLine.justify"><code class="name">var <span class="ident">justify</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="fpdf.line_break.TextLine.number_of_spaces_between_words"><code class="name">var <span class="ident">number_of_spaces_between_words</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="fpdf.line_break.TextLine.text_width"><code class="name">var <span class="ident">text_width</span> : float</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="fpdf.line_break.TextLine.trailing_nl"><code class="name">var <span class="ident">trailing_nl</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.line_break.CurrentLine" href="#fpdf.line_break.CurrentLine">CurrentLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.line_break.CurrentLine.add_character" href="#fpdf.line_break.CurrentLine.add_character">add_character</a></code></li>
<li><code><a title="fpdf.line_break.CurrentLine.automatic_break" href="#fpdf.line_break.CurrentLine.automatic_break">automatic_break</a></code></li>
<li><code><a title="fpdf.line_break.CurrentLine.automatic_break_possible" href="#fpdf.line_break.CurrentLine.automatic_break_possible">automatic_break_possible</a></code></li>
<li><code><a title="fpdf.line_break.CurrentLine.manual_break" href="#fpdf.line_break.CurrentLine.manual_break">manual_break</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.line_break.Fragment" href="#fpdf.line_break.Fragment">Fragment</a></code></h4>
<ul class="">
<li><code><a title="fpdf.line_break.Fragment.from_string" href="#fpdf.line_break.Fragment.from_string">from_string</a></code></li>
<li><code><a title="fpdf.line_break.Fragment.string" href="#fpdf.line_break.Fragment.string">string</a></code></li>
<li><code><a title="fpdf.line_break.Fragment.trim" href="#fpdf.line_break.Fragment.trim">trim</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.line_break.HyphenHint" href="#fpdf.line_break.HyphenHint">HyphenHint</a></code></h4>
<ul class="">
<li><code><a title="fpdf.line_break.HyphenHint.character_to_append" href="#fpdf.line_break.HyphenHint.character_to_append">character_to_append</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.character_to_append_style" href="#fpdf.line_break.HyphenHint.character_to_append_style">character_to_append_style</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.character_to_append_underline" href="#fpdf.line_break.HyphenHint.character_to_append_underline">character_to_append_underline</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.character_to_append_width" href="#fpdf.line_break.HyphenHint.character_to_append_width">character_to_append_width</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.current_line_character_index" href="#fpdf.line_break.HyphenHint.current_line_character_index">current_line_character_index</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.current_line_fragment_index" href="#fpdf.line_break.HyphenHint.current_line_fragment_index">current_line_fragment_index</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.number_of_spaces" href="#fpdf.line_break.HyphenHint.number_of_spaces">number_of_spaces</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.original_character_index" href="#fpdf.line_break.HyphenHint.original_character_index">original_character_index</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.original_fragment_index" href="#fpdf.line_break.HyphenHint.original_fragment_index">original_fragment_index</a></code></li>
<li><code><a title="fpdf.line_break.HyphenHint.width" href="#fpdf.line_break.HyphenHint.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.line_break.MultiLineBreak" href="#fpdf.line_break.MultiLineBreak">MultiLineBreak</a></code></h4>
<ul class="">
<li><code><a title="fpdf.line_break.MultiLineBreak.get_line_of_given_width" href="#fpdf.line_break.MultiLineBreak.get_line_of_given_width">get_line_of_given_width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.line_break.SpaceHint" href="#fpdf.line_break.SpaceHint">SpaceHint</a></code></h4>
<ul class="">
<li><code><a title="fpdf.line_break.SpaceHint.current_line_character_index" href="#fpdf.line_break.SpaceHint.current_line_character_index">current_line_character_index</a></code></li>
<li><code><a title="fpdf.line_break.SpaceHint.current_line_fragment_index" href="#fpdf.line_break.SpaceHint.current_line_fragment_index">current_line_fragment_index</a></code></li>
<li><code><a title="fpdf.line_break.SpaceHint.number_of_spaces" href="#fpdf.line_break.SpaceHint.number_of_spaces">number_of_spaces</a></code></li>
<li><code><a title="fpdf.line_break.SpaceHint.original_character_index" href="#fpdf.line_break.SpaceHint.original_character_index">original_character_index</a></code></li>
<li><code><a title="fpdf.line_break.SpaceHint.original_fragment_index" href="#fpdf.line_break.SpaceHint.original_fragment_index">original_fragment_index</a></code></li>
<li><code><a title="fpdf.line_break.SpaceHint.width" href="#fpdf.line_break.SpaceHint.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.line_break.TextLine" href="#fpdf.line_break.TextLine">TextLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.line_break.TextLine.fragments" href="#fpdf.line_break.TextLine.fragments">fragments</a></code></li>
<li><code><a title="fpdf.line_break.TextLine.justify" href="#fpdf.line_break.TextLine.justify">justify</a></code></li>
<li><code><a title="fpdf.line_break.TextLine.number_of_spaces_between_words" href="#fpdf.line_break.TextLine.number_of_spaces_between_words">number_of_spaces_between_words</a></code></li>
<li><code><a title="fpdf.line_break.TextLine.text_width" href="#fpdf.line_break.TextLine.text_width">text_width</a></code></li>
<li><code><a title="fpdf.line_break.TextLine.trailing_nl" href="#fpdf.line_break.TextLine.trailing_nl">trailing_nl</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>